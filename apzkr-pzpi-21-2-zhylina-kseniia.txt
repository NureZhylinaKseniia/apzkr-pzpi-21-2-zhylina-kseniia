Міністерство освіти та науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для керування коворкінгом

Студент гр. ПЗПІ-21-2	__________________ Жиліна К. І.
(підпис)
Керівник роботи	__________________ доц. Лещинський В.О.
(підпис)
	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:	__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)



Харків 
2024 р.
 
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			 6      
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

Жиліній Ксенії Іванівни
1.	Тема роботи: «Програмна система для керування коворкінгом»	
2.	Термін узгодження завдання курсової роботи « 25 » березня  2024 р.
3.	Термін здачі студентом закінченої роботи «28» червня 2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити:
Адміністрування користувачів та бронювань, можливість адміністраторів створювати нові кімнати та робочі місця, можливість користувачі створювати бронювання, переглядати всі коворкінги, кімнати та робочі місця, вхід/вихід з системи, реєстрація                                                	
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
Вступ, аналіз предметної області, постановка задачі, проектування програмної системи, розробка програмної системи, висновки, перелік джерел посилання, додаток А, додаток Б, додаток В, додаток Г, додаток Д	
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) UML діаграма прецедентів для менеджера, UML діаграма прецедентів для користувача, UML діаграма розгортання програмної системи, UML діаграма станів користувача, Схема фізичної моделі рівня ІоТ	


КАЛЕНДАРНИЙ ПЛАН


Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проекту	14.04.2024	Виконано
2	Проектування програмного
проекту	29.04.2024	Виконано
3	Кодування програмного проекту	21.05.2024	Виконано
4	Оформлення пояснювальної
записки	16.06.2024	Виконано
5	Захист курсової роботи	28.06.2024	Виконано

Дата видачі завдання « 25 » березня  2024 р.

Керівник	__________________ доц. Лещинський В.О.
(підпис)

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-2	__________________         Жиліна К. І.
(підпис)


РЕФЕРАТ


Пояснювальна записка до курсової роботи: 92 с., 5 рис., 5 додатків, 3 джерела.
КОВОРКІНГ, АДМІНІСТРУВАННЯ, БРОНЮВАННЯ, КІМНАТИ, РОБОЧІ МІСЦЯ, КЛЮЧ-КОД. 
	Мета роботи – це розробити програмний додаток для керування коворкінгами.
При розробці програмного забезпечення використовувались мови програмування, такі як C#, JavaScript, C++, мови розмітки, такі як CSS, HTML, фреймворки .NET MAUI, REACT, ASP .NET CORE.
Результатом виконання роботи є програмний застосунок, який  надає можливість ефективно адмініструвати коворкінгі та легко робити резервації з боку користувача.


ЗМІСТ


ВСТУП	 7
1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ	8
1.1 Бізнес-вимоги ........................................................................................................... 8
1.1.	1 Передумови ...................................................................................................... 8
1.1.2 Бізнес-можливості ........................................................................................... 9
1.1.3 Бізнес-цілі та критерії успіху ....................................................................... 11
1.1.4 Потреби клієнтів та ринку ............................................................................ 11
1.1.5 Бізнес-ризики ................................................................................................. 13
1.2 Концепція рішення ................................................................................................ 15
1.2.1 Окреслення концепції ................................................................................... 15
1.2.2 Головна функціональність ........................................................................... 16
1.2.3 Припущення та залежності .......................................................................... 17
1.3	 Рамки та обмеження ............................................................................................. 18
1.3.1 Рамки первинного випуску .......................................................................... 18
1.3.2 Рамки наступних випусків ........................................................................... 19
1.3.3 Обмеження та вийнятки ............................................................................... 20
1.4 Бізнес-контекст ...................................................................................................... 21
1.4.1 Профілі зацікавлених сторін ........................................................................ 21
1.4.2 Пріоритети проекту ....................................................................................... 22
1.4.3 Робоче середовище ........................................................................................ 23
2 ПОСТАНОВКА ЗАДАЧІ 	 25
3 ПРОЕКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ .................................................... 27
4 РОЗРОБКА ПРОГРАМНОЇ СИСТЕМИ ................................................................ 28
4.1 Розробка серверної частини ................................................................................. 28
4.1.1 Архітектура системи .................................................................................... 28
4.1.2 Розробка сервера .......................................................................................... 28
4.1.3 REST специфікація ...................................................................................... 29
4.1.3 Тестування .................................................................................................... 31
4.2 Розробка рівня ІоТ ................................................................................................ 31
4.2.1 Архітектура рівня ІоТ .................................................................................. 31
4.2.2 Програмна розробка рівня ІоТ .................................................................... 33
4.3 Розробка веб-додатку ............................................................................................ 34
4.3.1 Архітектура системи веб-додатку ............................................................... 34
4.3.2 Програмна розробка системи веб-додатку ................................................. 35
4.4 Розробка мобільного додатку ............................................................................... 37
4.4.1 Архітектура системи мобільного додатку ................................................. 37
4.4.2 Програмна розробка системи мобільного додатку ................................... 38
ВИСНОВКИ	 39
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ 	 40
ДОДАТОК А	 41
ДОДАТОК Б 	 46
ДОДАТОК В 	 55
ДОДАТОК Г	 59
ДОДАТОК Д 	 80


ВСТУП


Останніми роками поширення коворкінгів докорінно змінило традиційне офісне середовище, пропонуючи гнучкі робочі простори для фрілансерів, стартапів та віддалених працівників. Оскільки ці спільні середовища стають все більш популярними, потреба в ефективних системах управління, що інтегрують різні технологічні компоненти, стає все більш вираженою. У цій курсовій роботі представлено проектування, розробку та впровадження передової програмної системи, спеціально розробленої для управління коворкінгами.
У цьому документі детально описано архітектуру та функціональні можливості системи, включаючи технології та методології, використані при її розробці. У ньому також розглядаються виклики, що виникли в процесі впровадження, та стратегії, прийняті для їх подолання. Завдяки використанню цілісного підходу, що поєднує різні технологічні аспекти, ця програмна система має на меті встановити новий стандарт в управлінні коворкінгом, що в кінцевому підсумку сприятиме підвищенню продуктивності та співпраці в умовах гнучкого робочого середовища.


1 	АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	 Бізнес-вимоги

1.1.1	 Передумови


Коворкінги стрімко зростають у популярності як гнучка, економічно ефективна та орієнтована на громаду альтернатива традиційним офісним приміщенням. Однак менеджери коворкінгів стикаються зі специфічними викликами, намагаючись ефективно задовольнити різноманітні потреби своїх членів. Ці виклики включають в себе наступні:
−	Управління членством: Відстеження інформації про членів, їхніх планів та моделей використання може забирати багато часу та бути схильним до помилок.
−	Бронювання місць: Забезпечення безперебійного бронювання робочих столів, конференц-залів та інших ресурсів, уникаючи при цьому конфліктів у розкладі, має вирішальне значення, але часто важко керувати ним вручну.
−	Виставлення рахунків і платежі: Створення точних рахунків, відстеження платежів та управління різними планами членства може стати складним адміністративним тягарем.
−	Контроль доступу: Безпечне управління доступом членів до простору, особливо при роботі в режимі 24/7, вимагає ретельного нагляду.
−	Управління ресурсами: Без централізованої системи відстежувати обладнання, витратні матеріали та зручності може бути складно.
Програмна система для управління коворкінгом розроблена спеціально для вирішення цих завдань. Її мета - оптимізувати робочі процеси, покращити досвід учасників та підтримати зростання бізнесу коворкінгу. Це рішення принесе безпосередню користь як менеджерам коворкінгів, так і їхнім різноманітним клієнтам, включаючи фрілансерів, віддалені команди та великі підприємства, які шукають гнучкі варіанти робочого простору.


1.1.2	Бізнес-можливості


На ринку існує кілька програмних рішень для управління коворкінгами. Пропонуємо вам ознайомитися з кількома ключовими конкурентами та дізнатися, чим наше рішення відрізняється від них:
−	Nexudus: Комплексна платформа з управлінням членством, бронюванням та контролем доступу. Наша система буде зосереджена на наданні більш глибокої аналітики та розуміння використання простору для прийняття рішень, що базуються на даних.
−	Optix: Мобільне рішення для управління робочим простором та бронюванням. Ми прагнемо зробити додатковий акцент на безперебійній інтеграції з інструментами підвищення продуктивності, оптимізуючи робочі процеси, що виходять за рамки простого бронювання.
−	OfficeRnD: платформа, орієнтована на гібридні, гнучкі робочі середовища. Віддзеркалюючи їхню адаптивність, наша система надаватиме пріоритет функціям, які задовольняють унікальні потреби невеликих коворкінгів у білінгу, доступі та комунікації.
Особливу увагу в «Програмному забезпеченню для управління коворкінгом» буде приділено:
−	Оптимізації на основі даних: Глибше розуміння використання простору, вподобань користувачів та структури доходів дозволить операторам приймати обґрунтовані рішення щодо оптимізації простору, ціноутворення та пропозиції послуг.
−	Інтеграції продуктивності: Безшовна інтеграція з популярними інструментами для підвищення продуктивності (наприклад, Slack, Google Calendar) спрощує робочі процеси як для користувачів, так і для менеджерів.
−	Зосередженість на користувацькому досвіді: Інтуїтивно зрозумілий, простий у використанні інтерфейс як для менеджерів, так і для членів буде мати вирішальне значення для швидкого впровадження та зменшення адміністративного навантаження.
Монетизація та аналіз ринку:
−	Абонентська модель: Багаторівнева модель ціноутворення на основі підписки забезпечить гнучкість, масштабування відповідно до розміру та вимог до функцій коворкінгу.
−	Додатковий дохід: Комісійні за бронювання, здійснені через платформу, та преміум-послуги, такі як індивідуальна звітність, можуть створити додаткові потоки доходу.
Цільовий ринок: Програмний продукт в першу чергу орієнтований на малі та середні коворкінги. Цей сегмент часто недостатньо обслуговується великими платформами і має унікальні потреби. Зростаюча тенденція гібридної роботи та збільшення популярності коворкінгів свідчать про перспективність ринку.
Досягнення прибутковості:
−	Постійний дохід: Модель передплати забезпечує постійний потік доходів.
−	Масштабованість: Архітектура програмного забезпечення дозволяє економічно ефективне масштабування відповідно до зростання ринку.
−	Успіх клієнтів: Функції, що сприяють задоволенню та утриманню користувачів, сприятимуть довгостроковій прибутковості.
−	Маркетинг і продажі: Цілеспрямована стратегія охоплення менших коворкінгів та демонстрація цінності наших рішень матиме вирішальне значення для зростання.


1.1.3	Бізнес-цілі та критерії успіху


BO-1: Оптимізація операційної діяльності та зменшення витрат.
BO-2: Покращити досвід клієнтів.
BO-3: Сприяти зростанню доходів коворкінгів.
BO-4: Забезпечити адаптацію на ринку.
SC-1: Скоротити час, що витрачається на адміністративні завдання, на 30% протягом шести місяців після впровадження для операторів коворкінгів.
SC-2: Досягти зниження операційних накладних витрат коворкінгів на 20% протягом одного року після впровадження.
SC-3: Досягти рівня задоволеності учасників понад 85% (за результатами регулярних опитувань)
SC-4: Збільшити кількість бронювань, ініційованих членами (переговорні кімнати, спеціальні ресурси) на 25% протягом першого кварталу використання програмного забезпечення.
SC-5: Сприяти збільшенню використання простору на 15% завдяки інсайтам на основі даних.
SC-6: Сприяти зростанню середнього доходу на одного учасника на 10% за рахунок оптимізації продажів та додаткових послуг.
SC-7: Залучити 50 платоспроможних клієнтів протягом першого року після запуску.
SC-8: Досягти рівня утримання клієнтів понад 90%.


1.1.4	Потреби клієнтів та ринку


а) Керівники коворкінгів
−	Оптимізоване управління членством: Проста реєстрація, автоматичне поновлення, гнучкі плани членства та безпечне зберігання даних учасників.
−	Ефективне бронювання приміщень та ресурсів: Інтуїтивно зрозумілі календарі, наявність вільних приміщень/столів, вирішення конфліктів та інтегрована обробка платежів.
−	Глибока аналітика: Показники використання простору, тенденції доходів, моделі поведінки членів клубу для прийняття рішень.
−	Контроль доступу та безпека: Інтеграція з системами доступу (ключ-картки, мобільні перепустки) та можливість керувати правами користувачів.
−	Інструменти залучення спільноти: Каталог учасників, управління подіями, обмін повідомленнями або дискусійні дошки для посилення почуття приналежності до спільноти.
в) Учасники коворкінгу
−	Просте бронювання: Зручна навігація, доступність у режимі реального часу та зручний для мобільних пристроїв інтерфейс для бронювання столів, кімнат та ресурсів.
−	Зв'язок зі спільнотою: Профілі учасників, можливість знайти інших учасників, а також брати участь у заходах та дискусіях.
−	Управління ресурсами: Можливість переглядати наявність обладнання, резервувати спеціальні ресурси (наприклад, технічне обладнання, студії звукозапису).
−	Чітка комунікація: Сповіщення та оголошення від операторів коворкінгу.
с) Ринкові міркування
−	Гнучкість і масштабованість: Рішення має адаптуватися до коворкінгів різних розмірів та моделей.
−	Економічна ефективність: Ціна повинна відповідати ціннісній пропозиції, особливо для невеликих коворкінгів.
−	Простота використання: Зручний інтерфейс має вирішальне значення як для операторів, так і для учасників, щоб забезпечити адаптацію та мінімізувати потреби в навчанні.
−	Надійність і безпека: Клієнти очікують на високодоступну, безпечну платформу для захисту конфіденційних даних.


1.1.5	Бізнес-ризики


Ризик 1: Ринкова конкуренція.
Опис: На ринку програмного забезпечення для управління коворкінгами є кілька визнаних гравців. Нові учасники повинні запропонувати чітку диференціацію, щоб завоювати частку ринку.
Як зменшити ризик: 
−	Підкреслити унікальну ціннісну пропозицію (наприклад, розширена аналітика, сильна орієнтація на спільноту).
−	Орієнтуватися на конкретну нішу на ринку (наприклад, невеликі незалежні простори, коворкінгові мережі корпоративного рівня).
−	Пропонувати конкурентні ціни та гнучкі моделі підписки.
Ризик 2: Потреби клієнтів змінюються.
Опис: Індустрія коворкінгів та очікування учасників постійно розвиваються, що вимагає від програмного забезпечення випереджати їх.
Як зменшити ризик:
−	Побудувати міцний зворотний зв'язок з клієнтами, щоб розуміти нові потреби.
−	Розробляти модульну систему з потенціалом для інтеграції та кастомізації.
−	Підтримувати гнучкий цикл розробки для регулярного випуску нових функцій.
Ризик 3: Безпека та конфіденційність даних.
Опис: Програмне забезпечення коворкінгу обробляє конфіденційні дані учасників та бізнесу. Порушення безпеки чи конфіденційності може серйозно зашкодити репутації та довірі клієнтів.
Як зменшити ризик:
−	Інвестувати в надійну інфраструктуру безпеки та дотримуватись відповідних правил захисту даних (наприклад, GDPR).
−	Впроваджувати суворий контроль доступу та шифрування даних.
−	Бути прозорими щодо практик обробки даних і майте чітку політику конфіденційності.
Ризик 4: Проблеми з продажами та маркетингом.
Опис: Залучення клієнтів у конкурентному середовищі може бути дорогим і трудомістким процесом.
Як зменшити ризик:
−	Розробити цільову маркетингову стратегію, орієнтовану на канали коворкінг-індустрії (наприклад, конференції, онлайн-спільноти).
−	Пропонувати безкоштовні пробні версії або моделі freemium, щоб полегшити початкове впровадження.
−	Використовувати контент-маркетинг, щоб створити експертизу та побудувати довіру.
Ризик 5: Складність технологій та інтеграції.
Опис: Інтеграція з системами контролю доступу, платіжними шлюзами та іншими інструментами підвищення продуктивності може створювати технічні проблеми.
Як зменшити ризик:
−	Створити добре задокументований API для безперешкодної інтеграції.
−	Співпрацювати з постачальниками поширених коворкінг-технологій.
−	Надавати клієнтам відмінну технічну підтримку під час впровадження.


1.2 	Концепція рішення

1.2.1	Окреслення концепції


Наше бачення полягає в тому, щоб дати можливість коворкінгам процвітати, надаючи інтелектуальне та зручне для користувача програмне рішення. Ось як ми маємо намір це зробити:
−	Оптимізація операцій: Ми спрощуємо складнощі управління членством, бронюванням приміщень, виставленням рахунків та контролем доступу. Це означає, що менеджери коворкінгів витрачають менше часу на адміністративні завдання і мають більше часу, щоб зосередитися на розбудові своєї спільноти.
−	Зростання на основі даних: Наші аналітичні інструменти дають уявлення про моделі використання простору, вподобання резидентів та тенденції в доходах. Це дозволяє коворкінгам приймати обґрунтовані рішення щодо оптимізації планування, цінових стратегій та пропозицій послуг для стимулювання зростання.
−	Досвід, орієнтований на учасників: Наша платформа пропонує безперебійну роботу для учасників. Вони можуть легко бронювати робочі місця або конференц-зали, керувати своїми платежами та залишатися на зв'язку зі спільнотою. Підвищена зручність сприяє підвищенню задоволеності та лояльності учасників.
−	Орієнтованість на спільноту: Такі функції, як каталоги учасників та інструменти комунікації, сприяють налагодженню зв'язків і співпраці, що є основою успішного коворкінгу.
Ми віримо, що, зосередившись на простоті використання, глибокій аналітиці та формуванні почуття спільноти, наша система управління коворкінгом безпосередньо сприятиме успіху коворкінгів, які ми обслуговуємо.


1.2.2	 Головна функціональність


a) Менеджери коворкінгів:
MF-1: Управління членством: Безпечне управління профілем.
MF-2: Бронювання простору та ресурсів: Інтуїтивно зрозумілі візуальні календарі для робочих столів, кімнат та обладнання. Просте управління бронюванням та вирішення конфліктів.
MF-3: Контроль доступу: Ключові картки, системи мобільного доступу та управлінням відвідувачами.
MF-4: Інструменти для створення спільноти: Профілі учасників.
MF-5: Безпека даних: Надійні протоколи резервного копіювання та відновлення даних. Опції для експорту даних учасників та системних налаштувань для цілей відповідності або міграції.
MF-6: Аналітика даних: Математичні методи (наприклад, моделі прогнозування, аналіз трендів) для прогнозування попиту на приміщення, аналізу поведінки користувачів та оптимізації розподілу ресурсів.
MF-7: Системне адміністрування: Тонкий контроль над ролями та дозволами користувачів. Інструменти моніторингу стану, продуктивності та використання системи.
б) Учасники коворкінгу:
MF-8: Зручне бронювання: Доступність просторів та ресурсів у режимі реального часу зі зручним інтерфейсом, оптимізованим для мобільних пристроїв.
MF-9: Управління профілем: Можливість переглядати та оновлювати інформацію про профіль користувача.
MF-10: Доступ до ресурсів: Перегляд та бронювання спеціальних ресурсів (наприклад, конференц-зали, обладнання для запису тощо).


1.2.3	Припущення та залежності


Припущення:
−	Мінімальна технологічна грамотність: Передбачається, що керівники та учасники мають загальне розуміння використання веб-інтерфейсів або мобільних додатків.
−	Доступ до мережі: Система покладається на стабільне з'єднання з Інтернетом у коворкінгу для того, щоб керівники та учасники мали доступ до повного функціоналу.
−	Доступність даних: Точна аналітика залежить від постійного введення керівниками даних (наприклад, інформації про учасників, планування приміщень, бронювання).
−	Відповідальність учасників: Учасники коворкінгу повинні поважати правила бронювання та користування спільним простором у межах коворкінгу.
Залежності:
−	Хмарна інфраструктура: Програмне забезпечення, ймовірно, буде залежати від постачальника хмарного хостингу для забезпечення надійності та масштабованості.
−	Системи контролю доступу: У разі інтеграції з системою контролю доступу, коворкінг потребує сумісного обладнання (наприклад, зчитувачі ключ-карт, мобільні системи доступу).
−	Сторонні інтеграції: Додаткові функції, що використовують зовнішні сервіси (наприклад, інструменти для підвищення продуктивності, платіжні шлюзи), залежать від цих постачальників.


1.3 	Рамки та обмеження

1.3.1	Рамки первинного випуску


Проект передбачає створення програмного продукту, який буде доступний як і в браузері, так і на мобільних пристроях.
Функціональність першої версії:
Бек-частина застосунок:
−	Логіка бронювання: Обробка часових інтервалів, робочі процеси затвердження (якщо застосовно) та обмеження потужностей.
−	Безпека даних: Детальні заходи безпеки (шифрування, реєстрація доступу і т.д.).
Веб-частина застосунку: 
−	Налаштування: Створення облікового запису для менеджерів коворкінгу.
−	План приміщень: Візуалізованний план приміщення.
−	Адміністрування: Можливість керувати користувачами, налаштовувати загальносистемні параметри (сповіщення, інтеграції), отримувати доступ до детальних системних журналів або обробляйте масові дії.
−	Бронювання місць: Бронювання робочих столів і переговорних кімнат на основі календаря з візуалізацією доступності, вирішенням конфліктів і основними робочими процесами узгодження.
Мобільний застосунок:
−	Спрощенне користувацький досвід: Можливість бачити всі попередні та поточні бронювання, а також переглядати дійсне бронювання.
ІоТ:
−	Розумний замок: Відкриття по коду.
Безпека та дані:
−	Безпечний вхід: Автентифікація користувачів з використанням надійного пароля та шифруванням даних.
−	Практики роботи з даними: Чіткі політики обробки даних і контроль користувача над інформацією свого профілю (модифікація, можливість видалення).
Локалізація:
−	Основний інтерфейс: Підтримка однієї основної мови. Багатомовність планується в майбутньому.


1.3.2	Рамки наступних випусків


Покращення функцій:
−	Розширена аналітика: Глибше розуміння вподобань користувачів, прогнозування тенденцій та рекомендації щодо оптимізації простору.
−	Автоматизоване виставлення рахунків: Інтеграція з популярними платіжними шлюзами для безпечних платежів у додатку та спрощеного управління підпискою.
−	Гнучкі плани членства: Створення більш складних рівнів членства, додаткових послуг і моделей ціноутворення на основі використання.
−	Надійні інструменти для спільнот: Сприяння налагодженню зв'язків між членами спільноти, підбір наставників та створення груп за інтересами.
−	Управління ресурсами: Можливість визначати та бронювати певне обладнання (наприклад, проектори, звукозаписувальне обладнання), включаючи планування та відстеження запасів.
Розширені можливості:
−	Багатомовна підтримка: Пропонує повністю локалізований інтерфейс додатковими мовами для обслуговування ширшого міжнародного ринку.
−	Маркетингові інтеграції: Підключення до платформ email-маркетингу та CRM-інструментів для оптимізації лідогенерації та підтримки кампаній.
Стратегічні інтеграції:
−	Інструменти для підвищення продуктивності: Інтеграція з популярними календарями (Google Calendar, Outlook) для безперебійної синхронізації бронювання.
−	Системи розумних будівель: Потенційна майбутня інтеграція з технологіями розумних будівель для управління освітленням і кліматом на основі заповнюваності.


1.3.3	Обмеження та виключення


Технічні обмеження:
−	Сторонні залежності: Функціональність програмного забезпечення може бути обмежена доступністю або можливостями зовнішніх систем, з якими воно інтегрується (наприклад, контроль доступу, платіжні шлюзи).
−	Сумісність пристроїв: Підтримка певних систем контролю доступу або спеціалізованих ресурсів може вимагати спеціального обладнання, яке може бути недоступним для всіх.
−	Офлайн-функціональність: Початкові версії можуть мати обмежені можливості роботи в автономному режимі, які залежать насамперед від стабільного інтернет-з'єднання.
Операційні винятки:
−	Фінансовий облік: Програмне забезпечення не призначене для заміни повноцінної системи бухгалтерського обліку. Можливості виставлення рахунків та інвойсів, швидше за все, будуть зосереджені на основних потребах коворкінгів.
−	ІТ-підтримка на місці: Постачальник програмного забезпечення не може надавати пряму технічну підтримку на місці для вирішення проблем з обладнанням або мережею в межах коворкінгу.
−	Відповідність законодавству: Хоча система може бути розроблена з урахуванням принципів конфіденційності даних, оператор коворкінгу несе відповідальність за дотримання місцевих правил (GDPR тощо) при конкретному використанні програмного забезпечення.
Обмеження, пов'язані з конкретними функціями
−	Глибина аналітики (на початковому етапі): Ранні версії можуть мати базові звіти, а розширена аналітика та прогнозне моделювання з'являться в наступних версіях.
−	Масштаб кастомізації: Можливість налаштування зовнішнього вигляду платформи або робочих процесів може бути обмежена на початковому етапі впровадження.


1.4 	Бізнес-контент

1.4.1	Профілі зацікавлених сторін


У таблиці 1 розповідається про всі сторони, які зацікавлени проектом:

Таблиця 1 – Профілі зацікалених сторін
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Власник коворкінгу	Оптимізація діяльності, зростання доходів	Прагнення до інноваційних рішень	Бронювання приміщень, аналітика	Може мати обмежені ІТ-ресурси

Продовження таблиці 1
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Персонал коворкінгу	Потребує інтуїтивно зрозумілих інструментів, швидкого входження в курс справи	Побоюються змін, але відкриті до підвищення ефективності	Просте управління бронюванням, комунікація з учасниками	Обмежений час на навчання складному програмному забезпеченню
Учасники коворкінгу	Безперешкодне бронювання, зв'язок зі спільнотою, легкий доступ	Поєднання технічно підкованих і тих, хто прагне простоти	Система бронювання, профілі учасників, зручність для мобільних пристроїв	Очікують зручності, контролю конфіденційності


1.4.2	Пріорітети проекту


У таблиці 2 наведені загальні пріорітети, які має програмна система:

Таблиця 2 – Основні пріорітети проєкту
Показник	Опис	Пріорітет
План робіт	Перший реліз програмної системи має бути наявний до 10.06.2024.	Високий

Продовження таблиці 2
Показник	Опис	Пріорітет
Функціональність	Включити основні функції в першому релізі	Високий
Якість	Досягнути високу якість продукту	Високий
Персонал	Команда складається з одного програміста	Середній
Ціна	Бюджету не має	Середній


1.4.3	Робоче середовище


Технологічний стек та обґрунтування:
−	Backend (.NET): .NET забезпечує надійний і масштабований фреймворк для побудови основної логіки та обробки даних системи управління коворкінгом. Завдяки потужній підтримці функцій безпеки, оптимізації продуктивності та крос-платформенній сумісності вона є чудовим вибором для цього проекту.
−	Фронтенд (React): Компонентна архітектура React та фокус на швидких, динамічних користувацьких інтерфейсах матимуть вирішальне значення для забезпечення чуйного та зручного інтерфейсу як для менеджерів коворкінгу, так і для його учасників.
−	Мобільний (MAUI): MAUI є найкращою мовою для сучасної розробки додатків для Android, забезпечуючи стислий та виразний синтаксис, водночас гарантуючи нативну продуктивність та сумісність з екосистемою Android.
−	Інтеграція з ІоТ (Arduino): Мікроконтролери Arduino пропонують гнучке та економічно ефективне рішення для створення прототипів та сумісностей датчиків IoT, які покращують контроль доступу.
Безпека та захист даних:
−	Аутентифікація та авторизація: Реалізація надійної системи автентифікації (наприклад, OAuth 2.0) та контролю доступу на основі ролей для забезпечення дозволів на доступ до даних на основі типу користувача.
−	Шифрування: Шифрування конфіденційних даних як у стані спокою, так і під час передачі (наприклад, TLS для мережевого зв'язку).
−	Відповідність: Дотримання відповідних правил захисту даних, таких як GDPR, включно з політиками безпечного зберігання даних, реєстрації доступу та процедурами сповіщення про порушення.
−	Регулярні оновлення: Постійне оновлення патчів безпеки.


2 	ПОСТАНОВКА ЗАДАЧІ


Для початку роботи необхідно провести концептуальне моделювання предметної області.
	За допомогою програмної системи користувачі повинні мати можливість переглядати, додавати, зберігати, редагувати, шукати, фільтрувати та видаляти інформацію, що стосується коворкінга. Всі ці дії повинні виконувати різні групи користувачів, які мають намір використовувати додаток для різних цілей.
Система матиме розподіл за двома ролями користувачів:
−	звичайний користувач;
−	менеджер системи.
Ділення користувачів на звичайних користувачів та менеджерыв є стандартною практикою в розробці програмних систем. Кожна з цих груп має свої унікальні ролі, обов'язки та доступ до функціоналу системи. Була розроблена UML-діаграма прецедентів для звичайного користувача (див. додаток А.2) та менеджера (див. додаток А.1), а також описані інформаційні потреби:
У програмній системі звичайні користувачі матимуть можливість:
Реєструватися та авторизуватися:
−	можливість створення та управління особистим профілем;
−	вхід в систему зі своїми обліковими даними.
Робити резервацію:
−	можливість переглядати кімнати та їх складові елементи за допомогою інтуїтивно зрозумілої візуалізації кімнат;
−	робити фільтрацію;
−	отримувати дані про наявність вільних номерів у режимі реального часу, за для запобігання конфліктам з надмірним бронюванням;
−	резервувати одне місце в обраній кімнаті.
В свою чергу менеджер зможе:
Обробляти бронювання:
−	перегляд та видаляти заявки на резервацію робочого місця;
−	наявність інструментів для фільтрації бронювань, що є важливим для ефективного управління.
Відстежування користувачів:
−	швидкий доступ до профілів користувачів;
−	блокування користувачів у випадку порушень правил чи неправомірної поведінки.


3 	ПРОЕКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ


База даних має 6 таблиць та 15 неключових атрибутів. Нижче наведено детальний опис усіх зв’язків між таблицями в базі даних.
Визначено, що один користувач може робити багато резервацій, але на одну резервацію може бути записан тільки один користувач. 
Також передбачено, що одна резервація може бути сворена на декілька (багато) робочих місць, в свою чергу на одне і те саме робоче місце може бути зроблено багато резервацій в різні проміжку часу.
Визначено, що одне робоче місце може знаходитися в лише одній кімнаті, але в одній кімнаті може знаходитися багато робочих місць.
Крім того, одна кімната може належити лише одному коворкінгу, але один коворкінг може мати багато кімнат.
Зв’язок між коворкінгом та менеджером передбачає, що один коворкінг може мати багато менеджерів, але один менеджер може бути пов’язаний тільки з одним коворкінгом.


4 	РОЗРОБКА ПРОГРАМНОЇ СИСТЕМИ
4.1 	Розробка серверної частини

4.1.1	Архітектура системи


У самому початку проекту була виготовлена UML-діаграму розгортання (див. додаток А.3), щоб об'ємно представити структуру програмної системи, яка складається з п'яти ключових компонентів:
−	серверна частина;
−	база даних;
−	веб-застосунок;
−	мобільний застосунок;
−	ІoT-девайс.
Діаграма розгортання є значущим інструментом для візуалізації фізичної архітектури системи. Використовуючи її, було визначено розташування та зв'язки між компонентами, що спрощує проектування, аналіз та оптимізацію фізичної структури системи.
Також була створена діаграма станів (див. додаток А.4) для моделювання динамічної поведінки ключових елементів системи. Вона допомагає забезпечити чітке визначення поведінки системи, запобігаючи несподіваним помилкам і покращуючи взаємодію з користувачем.


4.1.2	Розробка сервера


У якості технології для розробки елементів серверної частини в проекті було використано ASP.NET Core Web API, обрана мова програмування - C#. Розробка здійснювалася у середовищі розробки Visual Studio, що забезпечило ефективність та зручність у процесі творення програмного продукту.
Для початку було створено веб-додаток та конфігурація сервісів (див. додаток Б.1, рядок 8). Далі додані сервісів, такі як контролери та репозиторії, які будуть використовуватися в додатку (див. додаток Б.1, рядки 9-15). Додано підключення до бази даних через Entity Framework, використовуючи PostgreSQL (див. додаток Б.1, рядки 17-18). Встановлюється підтримка Swagger для автоматичної генерації документації API сервісів (див. додаток Б.1, рядки 20-21). Додаток створюється, і в режимі розробки активується Swagger для документації API (див. додаток Б.1, рядки 22-27). Вказані базові опції для додатка, такі як перенаправлення з HTTP на HTTPS та авторизація (див. додаток Б.1, рядки 28-29) та визначено використання контролерів та запуск додатка, який слухатиме запити і виконуватиме відповідні операції (див. додаток Б.1, рядки 30-31).


4.1.3	REST специфікація 


Booking:
−	GET /api/booking/ – отримати всі наявні резервації
−	POST /api/booking/{id} – додати нову резервацію
−	GET /api/booking/{id} – отримати одну резервацію обрану за Id
−	PUT /api/booking/edit/{id} – змінити інформацію про обрану резервацію
−	DELETE /api/booking/delete/{id} –видалити обрану резервацію
−	GET /api/booking/byUser/{userId} – отримати всі резервації вибраного за Id користувача
CoworkingSpace:
−	GET /api/coworkingSpace/ – отримати всі коворкінги
−	POST /api/coworkingSpace/ – додати новий коворкінг
−	GET /api/coworkingSpace/{id} – отримати один коворкінг обраний за Id
−	PUT /api/coworkingSpace/edit/{id} – змінити інформацію про обраний коворкінг
−	DELETE /api/coworkingSpace/delete/{id} – видалити обраний коворкінг 
−	PUT /api/coworkingSpace/addManager – додати обраному коворкінгу менеджера
Manager:
−	GET /api/manager/ – отримати всіх менеджерів
−	POST /api/manager/ – додати нового менеджера
−	GET /api/manager/{id} – отримати одного менеджера обраного за Id
−	PUT /api/manager/edit/{id} – змінити інформацію про обраного менеджера
−	DELETE /api/manager/delete/{id} – видалити обраного менеджера
−	DELETE /api/manager/deleteUser/{id} – відалити обраного користувача
−	POST /api/manager/login – вхід в особистий кабінет
−	POST /api/manager/logout –вихід з особистого кабінета
Room:
−	GET /api/room/ – отримати всі кімнати
−	POST /api/room/ – додати нову кімнату
−	GET /api/room/{id} – отримати кімнату обрану за Id
−	PUT /api/room/edit/{id} –змінити інформацію про обрану кімнату
−	DELETE /api/room/delete/{id} –видалити обрану кімнату
−	GET /api/room/byCoworkingSpace/{coworkingSpaceId} – отримати всі кімнати обраного коворкінга
User:
−	GET /api/user/ – отримати всіх користувачів
−	POST /api/user/ – додати нового користувача
−	GET /api/user/{id} – отримати користувача обраного за Id
−	PUT /api/user/edit/{id} – змінити інформацію про обраного користувача
−	DELETE /api/user/delete/{id} – видалити обраного користувача
−	POST /api/user/login – вхід в особистий кабінет
−	POST /api/user/logout – вихід з особистого кабінета
Workplace
−	GET /api/workplace/ – отримати всі робочі місця
−	POST /api/workplace/ – додати нове робоче місце
−	GET /api/workplace/{id} – отримати робоче місце обране за Id
−	PUT /api/workplace/edit/{id} – змінити інформацію про обране робоче місце
−	DELETE /api/workplace/delete/{id} – видалити обране робоче місце
−	GET /api/workplace/byRoom/{roomId} – отримати всі робочі місця в обраній кімнаті


4.1.4	Тестування


Тестування програми було виконано використовуючи Swagger.
Початковим етапом була інтеграція Swagger у проект ASP.NET Core. Був встановл необхідний пакет Swagger через NuGet та налаштуван в стартап-класі додатка.
Swagger автоматично генерує документацію API на основі атрибутів та коментарів у коді. Ми використовували атрибути, такі як [ApiController], [Route], і додавали коментарі до методів для збільшення зрозумілості документації.
Використовуючи Swagger UI, ми перевірили, чи правильно вказані параметри запиту для кожного ендпоінта, та перевірили структуру відповіді. Це дозволило впевнитися в коректності роботи API та забезпечити відповідність до специфікації.


4.2 	Розробка рівня ІоТ

4.2.1	Архітектура рівня ІоТ


Розробка програми для пристрою IoT на мові програмування C++ відбувалась у середовищі симуляції Wokwi, що є важливим етапом для тестування та відлагодження перед фізичною реалізацією системи. Використання мікроконтроллера ESP32 у поєднанні із симулятором Wokwi надає можливість емулювати поведінку пристрою та взаємодію з мережею та інтернетом.
Основні переваги використання ESP32 включають його здатність до підключення до мережі, що робить його ідеальним вибором для пристроїв IoT. Можливість виходу в інтернет дозволяє здійснювати взаємодію з серверами, отримання та відправлення даних.
Додатково був використан wokwi-servo. Він дозволяє симулювати функціональність сервоприводу та тестувати взаємодію з ним в умовах, які наближені до реального використання.
Основні бібліотеки, які використовуються в коді, включають:
−	WiFi.h: Бібліотека для роботи з бездротовим з'єднанням Wi-Fi. Вона використовується для підключення мікроконтролера до мережі Wi-Fi.
−	ESP32Servo.h: Бібліотека для управління сервоприводом на платформі ESP32. В даному випадку використовується для контролю положення сервоприводу, який може відкривати дверь.
−	RTClib: Дозволяє взаємодіяти з годинниками реального часу (RTC), такими як DS1307, DS3231 та іншими. Використовується отримання поточної дати та часу.
−	Keypad: Сприяє використанню матричних клавіатур для введення даних. В даному випадку для вводу пароля для кімнати.
−	ArduinoSTL: Надає можливості стандартної бібліотеки шаблонів (STL) для Arduino. Реалізує загальні контейнери STL, такі як вектори, списки та рядки, що дозволяє використовувати розширені структури даних та алгоритми.
−	HTTPClient.h: Бібліотека для виконання HTTP-запитів. Використовується для взаємодії з сервером та виконання HTTP GET-запитів для отримання та оновлення інформації про тварину.
−	ArduinoJson.h: Бібліотека для роботи з форматом JSON на платформі Arduino. Використовується для обробки JSON-відповіді від сервера.
−	LiquidCrystal I2C: Керує дисплеями. Відображає пароль, який вводить користувач коворкінга.


4.2.2	Програмна розробка рівня ІоТ


Для візуалізації та простішого розуміння розміщення контроллера та зовнішних модулів приладу була додана схема (див. додаток А.5).
Після визначення схеми програми, переходимо до написання коду.
При розробці програмної системи «wifi-scan.ino» виступає в ролі основного коду програми, який інтегрує різні апаратні компоненти та обробляє основний логічний потік. Він включає в себе налаштування середовища розробки з необхідними бібліотеками, ініціалізацію апаратних компонентів та реалізацію основного циклу для обробки введення з клавіатури та зв'язку з сервером. Процес розробки включає налагодження Wi-Fi з'єднань, тестування HTTP запитів та забезпечення належного керування сервоприводом.
На етапі розробки, «InputCode.h» забезпечує необхідні функції для ефективного керування введенням даних користувачем. Це включає в себе конфігурацію клавіатури, реалізацію методів управління масивом вводу та забезпечення коректного оновлення дисплея. До завдань розробки входить написання та тестування коду для обробки різних взаємодій користувача, керування вмістом дисплея та інтеграція цих функцій з основною логікою програми у «wifi-scan.ino».
«VerifyCode.h» фокусується на внутрішньому зв'язку, необхідному для перевірки коду. Завдання розробки тут включають налаштування HTTP-клієнта, форматування корисного навантаження JSON і обробку відповідей сервера. Цей модуль розроблений таким чином, щоб бути надійним і обробляти різні сценарії відповідей, гарантуючи, що система може надійно перевіряти коди на сервері. Тестування включає в себе моделювання відповідей сервера і перевірку правильності роботи логіки перевірки за різних умов.
Таким чином, всі ці файли разом сприяють створенню добре структурованої програмної системи з чітким розподілом завдань між апаратною взаємодією, управлінням користувацькими даними та внутрішнім зв'язком, що полегшує модульний і підтримуваний процес розробки.


4.3 	Розробка веб-додатку

4.3.1	Архітектура системи веб-додатку


Додаток побудовано з використанням багаторазових React-компонентів, що сприяє створенню модульної та підтримуваної кодової бази. Це гарантує, що кожна частина програми є самодостатньою і може бути розроблена та протестована незалежно.
Компоненти управління даними:
−	Керують даними та бізнес-логікою додатку;
−	Забезпечують пошук, зберігання та маніпулювання даними, надаючи чистий інтерфейс для інших компонентів для взаємодії з даними;
−	Забезпечують цілісність та узгодженість основної функціональності додатку.
Компоненти інтерфейсу користувача:
−	Створюйте користувацький інтерфейс (UI) додатку за допомогою React-компонентів;
−	Відображають дані та реєструють взаємодію з користувачем, забезпечуючи адаптивний та зручний інтерфейс;
−	Відповідають за макет, структуру та зовнішній вигляд компонентів UI, забезпечуючи узгодженість та зручність використання.
Компоненти управління станом:
−	Виступають посередником між даними та компонентами інтерфейсу, полегшуючи комунікацію між ними;
−	Підтримують стан інтерфейсу користувача, забезпечуючи оновлення інтерфейсу у відповідь на зміни в даних;
−	Обробляти вхідні дані користувача та відповідно оновлювати компоненти даних, забезпечуючи коректне застосування бізнес-логіки до даних.
Така архітектура на основі компонентів забезпечує чіткий розподіл завдань, що дозволяє ефективно розробляти, тестувати та підтримувати систему управління коворкінгом.


4.3.2	Програмна розробка системи веб-додатку


Хуки React'а useState та useEffect використовуються для управління станом, забезпечуючи чуйний та інтерактивний користувацький досвід. Це дозволяє додатку ефективно реагувати на взаємодію з користувачем та зміни даних.
Інтерфейс підтримує кілька мов за допомогою файлів локалізації, що дозволяє користувачам легко перемикатися між англійською та українською мовами. Це гарантує, що додаток буде доступним для ширшої аудиторії.
Ключові сервіси та компоненти:
«AuthService» відповідає за процеси автентифікації користувачів. Вона обробляє операції реєстрації, входу та виходу користувачів, забезпечуючи безпечне керування сеансами користувачів. Цей сервіс взаємодіє з сервером для перевірки облікових даних користувача та управління даними сеансу.
«BookingService» керує всіма операціями, пов'язаними з бронюванням. Сюди входить створення нових бронювань, пошук існуючих бронювань за різними критеріями (наприклад, ідентифікатор робочого місця або ідентифікатор користувача) і видалення бронювань. Це гарантує, що користувачі можуть ефективно керувати бронюванням своїх робочих місць.
«UserService» виконує операції, пов'язані з даними користувачів. Сюди входить отримання інформації про користувачів, оновлення профілів користувачів і керування обліковими записами користувачів. Він надає необхідний функціонал для підтримки інформації про користувачів та забезпечення актуальності даних користувачів.
«CoworkingSpaceService» відповідає за управління даними коворкінгу. Він виконує такі операції, як вибірка всіх коворкінгів, пошук приміщень за ідентифікатором менеджера та управління даними про окремі приміщення. Ця послуга гарантує, що інформація про доступні коворкінги є доступною та керованою.
«RoomService» фокусується на управлінні даними про приміщення в коворкінгу. Він включає в себе операції з пошуку всіх приміщень, створення нових приміщень та управління даними про приміщення. Цей сервіс відіграє вирішальну роль в організації планування коворкінгу та забезпеченні точного збереження інформації про приміщення.
«WorkplaceService» займається управлінням окремими робочими місцями в приміщенні. Він дозволяє отримувати робочі місця за ідентифікатором кімнати та створювати нові робочі місця. Цей сервіс гарантує, що розподіл та управління робочими місцями здійснюється ефективно.


4.4 	Розробка мобільного додатку

4.4.1	Архітектура системи мобільного додатку


Мобільний додаток для системи управління коворкінгом було розроблено з використанням .NET MAUI (Multi-platform App UI) у поєднанні з архітектурою MVVM (Model-View-ViewModel). Ця потужна комбінація пропонує численні переваги, забезпечуючи надійний, підтримуваний і масштабований користувальницький інтерфейс, який покращує загальний досвід як для клієнтів, так і для менеджерів.
Переваги:
−	Підтримка архітектури MVVM в .NET MAUI сприяє ефективній практиці розробки. Такі функції, як Hot Reload, дозволяють розробникам бачити зміни в реальному часі без перезапуску програми, що прискорює процес розробки.
−	Використання MVVM з .NET MAUI гарантує, що інтерфейс залишається послідовним і масштабованим на різних платформах. ViewModel керує станом та поведінкою інтерфейсу, що полегшує реалізацію адаптивних макетів та адаптивного дизайну.
−	Поєднання .NET MAUI та MVVM дозволяє створювати багаторазові компоненти та елементи керування, зменшуючи дублювання та підвищуючи якість коду. Це призводить до більш чистого та зручного для обслуговування коду.
−	.NET MAUI полегшує реалізацію багатомовної підтримки, дозволяючи користувачам перемикатися між англійською та українською мовами. 


4.4.2	Програмна розробка системи мобільного додатку


Мобільний додаток використовує модульні компоненти та сервіси, щоб забезпечити підтримку та ефективність кодової бази. Завдяки використанню багаторазових компонентів, кожна частина програми залишається автономною, що дозволяє проводити незалежну розробку та тестування. Ця модульність має вирішальне значення для підтримки чистої та масштабованої архітектури.
Ключові сервіси та компоненти:
BookingService контролює всі операції, пов'язані з управлінням бронюванням. Він дозволяє користувачам переглядати їхню історію. Це гарантує, що користувачі можуть ефективно організовувати та підтримувати бронювання коворкінгу.
UserService виконує операції з даними користувачів. Сюди входить пошук, оновлення, а також управління створенням нових облікових записів. Він надає необхідну функціональність для забезпечення актуальності та належного управління даними користувачів.


ВИСНОВКИ


В результаті виконанння роботи, було розроблено програмне забезпечення для управління коворкінгами, яке задовольняє зростаючу потребу в ефективних, гнучких і зручних рішеннях в індустрії спільного використання робочого простору. Завдяки інтеграції таких функцій, як автоматизоване бронювання, управління ресурсами та підтримка користувачів, ця система пропонує комплексний інструмент як для адміністраторів простору, так і для його учасників.
Програмне забезпечення не лише впорядковує щоденні операції, але й покращує загальний досвід користувачів, сприяючи створенню продуктивного середовища для співпраці. Завдяки використанню сучасних технологій та дотриманню найкращих практик у розробці програмного забезпечення, ця система розроблена для масштабування та адаптації до мінливих потреб коворкінгів.
Зрештою, цей проект підкреслює критичну роль технологій у трансформації управління коворкінгами, забезпечуючи надійну основу для подальшого зростання та успіху в цьому динамічному секторі.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
1.	Посилання на демонстрацію роботи на YouTube:

2.	Посилання на код програмної системи:

3.	Посилання на код для рівня ІоТ:
https://wokwi.com/projects/398959428185329665


ДОДАТОК А
Діаграми
А.1 UML діаграма прецедентів для менеджера
 
Рисунок 1 - UML діаграма прецедентів для менеджера


А.2 UML діаграма прецедентів для користувача
 
Рисунок 2 - UML діаграма прецедентів для користувача


А.3 UML діаграма розгортання програмної системи
 
Рисунок 3 - UML діаграма розгортання програмної системи


А.4 UML діаграма станів користувача
 
Рисунок 4 - UML діаграма станів користувача


А.5 Схема фізичної моделі рівня ІоТ
 
Рисунок 5 - Схема фізичної моделі рівня ІоТ


ДОДАТОК Б
Код сервера
Б.1 Код вхідного файлу «Program» для конфігурації та запуску додатка:

 1 using Application;
 2 using Application.DBContext;
 3 using Application.Repositories;
 4 using Microsoft.AspNetCore.Identity;
 5 using Microsoft.EntityFrameworkCore;
 6 using Application.Models;
 7 using Microsoft.OpenApi.Models;
 8 
 9 var builder = WebApplication.CreateBuilder(args);
10 
11 builder.Services.AddControllers();
12 builder.Services.AddCors();
13 builder.Services.AddScoped<IUserRepository, UserRepository>();
14 builder.Services.AddScoped<IManagerRepository, ManagerRepository>();
15 builder.Services.AddScoped<IBookingRepository, BookingRepository>();
16 builder.Services.AddScoped<IWorkplaceRepository, WorkplaceRepository>();
17 builder.Services.AddScoped<IRoomRepository, RoomRepository>();
18 builder.Services.AddScoped<ICoworkingSpaceRepository, CoworkingSpaceRepository>();
19 
20 builder.Services.AddHttpContextAccessor();
21 builder.Services.AddDbContext<AppDbContext>(options => 
22     options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));
23 
24 builder.Services.AddAutoMapper(typeof(Program));
25 
26 builder.Services.AddEndpointsApiExplorer();
27 builder.Services.AddSwaggerGen();
28 
29 var app = builder.Build();
30 
31 app.UseCors(build => build
32                         .AllowAnyHeader()
33                         .AllowAnyMethod()
34                         .SetIsOriginAllowed((host) => true)
35                         .AllowCredentials()
36                     );
37 
38 if (app.Environment.IsDevelopment())
39 {
40     app.UseSwagger();
41     app.UseSwaggerUI();
42 }
43 
44 app.UseRouting();
45 
46 app.UseAuthorization();
47 
48 app.MapControllers();
49 
50 app.Run();


Б2. Код файлу «BookingAnalizer.cs»:

 1 using Application.Models;
 2 using Application.Repositories;
 3 using Microsoft.AspNetCore.Mvc;
 4 
 5 namespace Application.Util
 6 {
 7     class TimeRange
 8     {
 9         public TimeSpan Start { get; set; }
10         public TimeSpan End { get; set; }
11     }
12 
13     public class BookingAnalyzer
14     {
15         private readonly IRoomRepository _roomRepository;
16         private readonly IWorkplaceRepository _workplaceRepository;
17         private readonly IBookingRepository _bookingRepository;
18 
19         public BookingAnalyzer(IRoomRepository roomRepository, IWorkplaceRepository workplaceRepository, IBookingRepository bookingRepository)
20         {
21             _roomRepository = roomRepository;
22             _workplaceRepository = workplaceRepository;
23             _bookingRepository = bookingRepository;
24         }
25 
26         public List<Booking> GetAllBookingsInThisWorkplace(int id)
27         {
28             var rooms = _roomRepository.GetRoomsByCoworkingSpaceId(id);
29             if (rooms == null) { return null; }
30 
31             List<Workplace> allWorkplaces = new List<Workplace>();
32             foreach (var room in rooms)
33             {
34                 var workplaces = _workplaceRepository.GetWorkplacesByRoomId(room.RoomId);
35                 allWorkplaces.AddRange(workplaces);
36             }
37 
38             if (allWorkplaces.Count == 0) { return null; }
39 
40             List<Booking> allBookings = new List<Booking>();
41             foreach (var workplace in allWorkplaces)
42             {
43                 var booking = _bookingRepository.GetBookingByWorkplaceId(workplace.WorkplaceId);
44                 allBookings.AddRange(booking);
45             }
46 
47             return allBookings;
48         }
49 
50         static int CountOverlaps(List<TimeRange> ranges, TimeSpan time)
51         {
52             int count = 0;
53             foreach (var range in ranges)
54             {
55                 if (time >= range.Start && time <= range.End)
56                 {
57                     count++;
58                 }
59             }
60             return count;
61         }
62 
63         public (TimeSpan start, TimeSpan end) GetMostPopularTimePeriod(int id)
64         {
65             var bookings = GetAllBookingsInThisWorkplace(id);
66 
67             List<TimeRange> timeRanges = new List<TimeRange>();
68 
69             foreach (var booking in bookings)
70             {
71                 timeRanges.Add(new TimeRange { Start = booking.StartDateTime.TimeOfDay, End = booking.EndDateTime.TimeOfDay });
72             }
73 
74             TimeSpan startTime = TimeSpan.FromHours(0);
75             TimeSpan endTime = TimeSpan.FromHours(23).Add(TimeSpan.FromMinutes(59));
76             int maxOverlaps = 0;
77             TimeSpan maxOverlapStartTime = startTime;
78             TimeSpan maxOverlapEndTime = startTime;
79 
80             for (TimeSpan time = startTime; time <= endTime; time = time.Add(TimeSpan.FromMinutes(1)))
81             {
82                 int overlaps = CountOverlaps(timeRanges, time);
83                 if (overlaps > maxOverlaps)
84                 {
85                     maxOverlaps = overlaps;
86                     maxOverlapStartTime = time;
87                     maxOverlapEndTime = time.Add(TimeSpan.FromMinutes(59));
88                 }
89             }
90             return (maxOverlapStartTime, maxOverlapEndTime);
91         }
92     }
93 }


Б3. Код файлу «BookingRepository.cs»:

 1 using Microsoft.EntityFrameworkCore;
 2 using System.Linq;
 3 using Application.Models;
 4 using Application.DBContext;
 5 
 6 namespace Application.Repositories
 7 {
 8     public class BookingRepository : IBookingRepository
 9     {
10         private readonly AppDbContext _context;
11 
12         public BookingRepository(AppDbContext context)
13         {
14             _context = context;
15         }
16 
17         public IQueryable<Booking> GetAllBookings()
18         {
19             return _context.Booking.Include(k => k.User).Include(k => k.Workplaces).AsQueryable();
20         }
21 
22         public Booking GetBookingById(int id)
23         {
24             return _context.Booking.Include(k => k.User).Include(k => k.Workplaces).FirstOrDefault(k => k.BookingId == id);
25         }
26 
27         public IEnumerable<Booking> GetBookingsByUserId(int userId)
28         {
29             return _context.Booking
30                     .Where(booking => booking.User.UserId == userId)
31                     .Include(k => k.Workplaces)
32                     .ToList();
33         }
34 
35         public IEnumerable<Booking> GetBookingByWorkplaceId(int workplaceId)
36         {
37             var bookings = GetAllBookings();
38 
39             List<Booking> result = new List<Booking>();
40 
41             foreach (var booking in bookings) 
42             {
43                 if(booking.Workplaces.Select(x => x.WorkplaceId).Contains(workplaceId))
44                 {
45                     result.Add(booking);
46                 }
47             }
48 
49             return result;
50         }
51 
52         public void CreateBooking(Booking booking)
53         {
54             _context.Booking.Add(booking);
55             _context.SaveChanges();
56         }
57 
58         public void UpdateBooking(Booking booking)
59         {
60             _context.Entry(booking).State = EntityState.Modified;
61             _context.SaveChanges();
62         }
63 
64         public void DeleteBooking(int id)
65         {
66             var booking = _context.Booking.Find(id);
67             if (booking != null)
68             {
69                 _context.Booking.Remove(booking);
70                 _context.SaveChanges();
71             }
72         }
73     }
74 }


Б4. Код файлу «CoworkingSpaceRepository.cs»:

 1 using Microsoft.EntityFrameworkCore;
 2 using System.Linq;
 3 using Application.Models;
 4 using Application.DBContext;
 5 using Application.Repositories;
 6 
 7 namespace Application.Repositories
 8 {
 9     public class CoworkingSpaceRepository : ICoworkingSpaceRepository
10     {
11         private readonly AppDbContext _context;
12 
13         public CoworkingSpaceRepository(AppDbContext context)
14         {
15             _context = context;
16         }
17 
18         public IQueryable<CoworkingSpace> GetAllCoworkingSpaces()
19         {
20             return _context.CoworkingSpace.Include(d => d.Manager).AsQueryable();
21         }
22 
23         public CoworkingSpace GetCoworkingSpaceById(int id)
24         {
25             return _context.CoworkingSpace.Include(d => d.Manager).FirstOrDefault(d => d.CoworkingSpaceId == id);
26         }
27 
28         public List<CoworkingSpace> GetCoworkingSpaceByManagerId(int managerId)
29         {
30             return _context.CoworkingSpace
31                     .Where(coworkingSpace => coworkingSpace.Manager.ManagerId == managerId)
32                     .ToList();
33         }
34 
35         public void AddCoworkingSpace(CoworkingSpace coworkingSpace)
36         {
37             _context.CoworkingSpace.Add(coworkingSpace);
38             _context.SaveChanges();
39         }
40 
41         public void AddCoworkingSpaceManager(CoworkingSpace coworkingSpace)
42         {
43             _context.Entry(coworkingSpace).State = EntityState.Modified;
44             _context.SaveChanges();
45         }
46 
47         public void UpdateCoworkingSpace(CoworkingSpace coworkingSpace)
48         {
49             _context.Entry(coworkingSpace).State = EntityState.Modified;
50             _context.SaveChanges();
51         }
52 
53         public void DeleteCoworkingSpace(int id)
54         {
55             var coworkingSpace = _context.CoworkingSpace.FirstOrDefault(n => n.CoworkingSpaceId == id);
56 
57             if (coworkingSpace != null)
58             {
59                 _context.CoworkingSpace.Remove(coworkingSpace);
60                 _context.SaveChanges();
61             }
62         }
63     }
64 }


ДОДАТОК В
Код ІоТ пристроя
В1. Код файлу «InputCode.h»:

 1 #include <LiquidCrystal_I2C.h>
 2 #include <Keypad.h>
 3 
 4 #define ROW_NUM     4 
 5 #define COLUMN_NUM  4 
 6 
 7 char keys[ROW_NUM][COLUMN_NUM] = 
 8 {
 9   {'1','2','3', 'A'},
10   {'4','5','6', 'B'},
11   {'7','8','9', 'C'},
12   {'*','0','#', 'D'}
13 };
14 
15 byte pin_rows[ROW_NUM]      = {19,18,5,17};
16 byte pin_column[COLUMN_NUM] = {16,4,2,15};
17 
18 LiquidCrystal_I2C lcd(0x27, 16, 2);
19 Keypad keypad = Keypad(makeKeymap(keys), pin_rows, pin_column, ROW_NUM, COLUMN_NUM);
20 
21 const int maxInput = 6;
22 
23 char inputArray[maxInput]; // Array to store entered characters (changed to size maxInput)
24 int arrayIndex = 0; // Index to keep track of the current position in the array
25 
26 void addCharacter(char key) 
27 {
28   if (arrayIndex < maxInput) 
29   {
30     inputArray[arrayIndex++] = key;
31   }
32 }
33 
34 void deleteLastCharacter() 
35 {
36   if (arrayIndex > 0) {
37     arrayIndex--;
38     inputArray[arrayIndex] = '\0';
39   }
40 }
41 
42 void clearArray() 
43 {
44   arrayIndex = 0;
45   for (int i = 0; i < maxInput; i++) {
46     inputArray[i] = '\0';
47   }
48 }
49 
50 void printToLCD() 
51 {
52   lcd.clear();
53   lcd.setCursor(0, 0);
54   lcd.print(inputArray);
55 }
56 
57 void printMessageToLCD(String message)
58 {
59   lcd.clear();
60   lcd.setCursor(0, 0);
61   lcd.print(message);
62 }
63 
64 void clearLCD(bool outputMessage) 
65 {
66   lcd.clear();
67   if(outputMessage)
68   {
69     lcd.setCursor(0, 0);
70     lcd.print("Input");
71     lcd.setCursor(0, 1);
72     lcd.print("Cleared");
73     delay(2000);
74     lcd.clear();
75   }
76 }


В2. Код файлу «VerifyCode.h»:

1  bool VerifyCode(String serverUrl, int code, int roomId, tm timestamp)
2  {
3    HTTPClient http;
4    String url = serverUrl + "api/booking/checkCode/" + String(roomId);
5
6    http.begin(url);
7    http.addHeader("Content-Type", "application/json");
8
9    char formattedTime[25];
10   strftime(formattedTime, sizeof(formattedTime), "%Y-%m-%dT%H:%M:%S.000Z", &timestamp);
11   String notificationDateTime = String(formattedTime);
12
13   DynamicJsonDocument jsonDocument(1024);
14   jsonDocument["code"] = code;
15   jsonDocument["timestamp"] = formattedTime;
16
17   String jsonPayload;
18   serializeJson(jsonDocument, jsonPayload);
19
20   int httpResponseCode = http.POST(jsonPayload);
21
22   Serial.printf("HTTP Response code: %d\n", httpResponseCode);
23   if (httpResponseCode >= 200 && httpResponseCode <= 400) 
24   {
25     DynamicJsonDocument jsonDocumentResponse(1024);
26     deserializeJson(jsonDocumentResponse, http.getString());
27
28     if (jsonDocumentResponse["code"].as<int>() == code)
29     {
30       return true;
31     }
32   }
33   return false;
34 }


ДОДАТОК Г
Код веб-застосунка
Г1. Код файла «AdminAllBookingsPage.js»:

1  // AdminAllBookings.js
2  import React, { useEffect, useState } from 'react';
3  import { getAllBookings, deleteBooking } from '../../services/BookingsService';
4  import '../../styles/adminBookings.css';
5  import { FormattedMessage } from 'react-intl';
6
7  const AdminAllBookings = () => {
8    const [bookings, setBookings] = useState([]);
9    const [sortConfig, setSortConfig] = useState({ key: 'startDateTime', direction: 'ascending' });
10   const [loading, setLoading] = useState(true);
11   const [error, setError] = useState(null);
12
13   useEffect(() => {
14     fetchBookings();
15   }, []);
16
17   const fetchBookings = async () => {
18     setLoading(true);  // Start loading
19     setError(null);    // Clear previous errors
20     try {
21       const data = await getAllBookings();
22       setBookings(data);
23     } catch (error) {
24       console.error('Error fetching bookings:', error);
25       setError('Failed to fetch bookings');
26     } finally {
27       setLoading(false); // Stop loading
28     }
29   };
30
31   const handleSort = (key) => {
32     let direction = 'ascending';
33     if (sortConfig.key === key && sortConfig.direction === 'ascending') {
34       direction = 'descending';
35     }
36     setSortConfig({ key, direction });
37   };
38
39   const sortedBookings = bookings.length > 0 ? [...bookings].sort((a, b) => {
40     const aValue = a[sortConfig.key];
41     const bValue = b[sortConfig.key];
42
43     if (typeof aValue === 'string' && typeof bValue === 'string') {
44       return sortConfig.direction === 'ascending'
45         ? aValue.localeCompare(bValue)
46         : bValue.localeCompare(aValue);
47     } else if (aValue instanceof Date && bValue instanceof Date) {
48       return sortConfig.direction === 'ascending'
49         ? new Date(aValue) - new Date(bValue)
50         : new Date(bValue) - new Date(aValue);
51     } else {
52       return sortConfig.direction === 'ascending'
53         ? aValue - bValue
54         : bValue - aValue;
55     }
56   }) : [];
57
58   const handleDelete = async (bookingId) => {
59     try {
60       await deleteBooking(bookingId);
61       setBookings(bookings.filter((booking) => booking.bookingId !== bookingId));
62     } catch (error) {
63       console.error('Error deleting booking:', error);
64       setError('Failed to delete booking');
65     }
66   };
67
68   if (loading) {
69     return <div>Loading...</div>;
70   }
71
72   if (error) {
73     return <div>Error: {error}</div>;
74   }
75
76   return (
77     <div className="admin-all-bookings">
78       <h1><FormattedMessage id="adminAllBookings.allBookings" defaultMessage="All Bookings" /></h1>
79       <table>
80         <thead>
81           <tr>
82             <th onClick={() => handleSort('bookingId')}><FormattedMessage id="adminAllBookings.bookingID" defaultMessage="Booking ID" /></th>
83             <th onClick={() => handleSort('startDateTime')}><FormattedMessage id="adminAllBookings.startDateTime" defaultMessage="Start Date & Time" /></th>
84             <th onClick={() => handleSort('endDateTime')}><FormattedMessage id="adminAllBookings.endDateTime" defaultMessage="End Date & Time" /></th>
85             <th><FormattedMessage id="adminAllBookings.bookingCode" defaultMessage="Booking Code" /></th>
86             <th><FormattedMessage id="adminAllBookings.user" defaultMessage="User" /></th>
87             <th><FormattedMessage id="adminAllBookings.actions" defaultMessage="Actions" /></th>
88           </tr>
89         </thead>
90         <tbody>
91           {sortedBookings.map((booking) => (
92             <tr key={booking.bookingId}>
93               <td>{booking.bookingId}</td>
94               <td>{new Date(booking.startDateTime).toLocaleString()}</td>
95               <td>{new Date(booking.endDateTime).toLocaleString()}</td>
96               <td>{booking.bookingCode}</td>
97               <td>{booking.user?.fullname}</td>
98               <td>
99                 <button onClick={() => handleDelete(booking.bookingId)}>Delete</button>
100              </td>
101            </tr>
102          ))}
103        </tbody>
104      </table>
105    </div>
106  );
107};
108
109 export default AdminAllBookings;


Г2. Код файла «AdminAllUsersPage.js»:

1  // AdminAllUsers.js
2  import React, { useEffect, useState } from 'react';
3  import { getAllUsers, deleteUser } from '../../services/UserService';
4  import '../../styles/adminUsers.css';
5  import { FormattedMessage } from 'react-intl';
6
7  const AdminAllUsers = () => {
8    const [users, setUsers] = useState([]);
9    const [sortConfig, setSortConfig] = useState({ key: 'username', direction: 'ascending' });
10   const [loading, setLoading] = useState(true);
11   const [error, setError] = useState(null);
12
13   useEffect(() => {
14     fetchUsers();
15   }, []);
16
17   const fetchUsers = async () => {
18     setLoading(true);
19     setError(null);
20     try {
21       const data = await getAllUsers();
22       setUsers(data);
23     } catch (error) {
24       console.error('Error fetching users:', error);
25       setError('Failed to fetch users');
26     } finally {
27       setLoading(false);
28     }
29   };
30
31   const handleSort = (key) => {
32     let direction = 'ascending';
33     if (sortConfig.key === key && sortConfig.direction === 'ascending') {
34       direction = 'descending';
35     }
36     setSortConfig({ key, direction });
37   };
38
39   const sortedUsers = users.length > 0 ? [...users].sort((a, b) => {
40     const aValue = a[sortConfig.key];
41     const bValue = b[sortConfig.key];
42
43     if (typeof aValue === 'string' && typeof bValue === 'string') {
44       return sortConfig.direction === 'ascending'
45         ? aValue.localeCompare(bValue)
46         : bValue.localeCompare(aValue);
47     } else {
48       return sortConfig.direction === 'ascending'
49         ? aValue - bValue
50         : bValue - aValue;
51     }
52   }) : [];
53
54   const handleDelete = async (userId) => {
55     try {
56       await deleteUser(userId);
57       setUsers(users.filter((user) => user.userId !== userId));
58     } catch (error) {
59       console.error('Error deleting user:', error);
60       setError('Failed to delete user');
61     }
62   };
63
64   if (loading) {
65     return <div>Loading...</div>;
66   }
67
68   if (error) {
69     return <div>Error: {error}</div>;
70   }
71
72   return (
73     <div className="admin-all-users">
74       <h1><FormattedMessage id="adminAllUsers.allUsers" defaultMessage="All Users" /></h1>
75       <table>
76         <thead>
77           <tr>
78             <th onClick={() => handleSort('userId')}><FormattedMessage id="adminAllUsers.userID" defaultMessage="User ID" /></th>
79             <th onClick={() => handleSort('email')}><FormattedMessage id="adminAllUsers.email" defaultMessage="Email" /></th>
80             <th onClick={() => handleSort('fullname')}><FormattedMessage id="adminAllUsers.fullName" defaultMessage="Full Name" /></th>
81             <th><FormattedMessage id="adminAllUsers.Actions" defaultMessage="Actions" /></th>
82           </tr>
83         </thead>
84         <tbody>
85           {sortedUsers.map((user) => (
86             <tr key={user.userId}>
87               <td>{user.userId}</td>
88               <td>{user.email}</td>
89               <td>{user.fullname}</td>
90               <td>
91                 <button onClick={() => handleDelete(user.userId)}>Delete</button>
92               </td>
93             </tr>
94           ))}
95         </tbody>
96       </table>
97     </div>
98   );
99 };
100
101 export default AdminAllUsers;


Г3. Код файла «AdminRoomsPage.js»:

1  import React, { useEffect, useState } from 'react';
2  import { getCoworkingSpaceByManagerId } from '../../services/CoworkingSpacesService';
3  import { getAllRooms, createRoom } from '../../services/RoomsService';
4  import { getAllWorkplacesByRoomId, createWorkplace } from '../../services/WorkplacesService';
5  import '../../styles/room.css';
6  import { FormattedMessage } from 'react-intl';
7
8  const AdminRooms = () => {
9    const [coworkingSpace, setCoworkingSpace] = useState(null);
10   const [rooms, setRooms] = useState([]);
11   const [loading, setLoading] = useState(true);
12   const [error, setError] = useState(null);
13   const [newRoomData, setNewRoomData] = useState({ roomName: '', description: '' });
14   const [newWorkplaceData, setNewWorkplaceData] = useState({ roomId: '', hourlyRate: '' });
15
16   const managerIdData = localStorage.getItem('managerId');
17   let managerId = null;
18   if (managerIdData) {
19     managerId = JSON.parse(managerIdData);
20   }
21
22   useEffect(() => {
23     const fetchCoworkingSpace = async () => {
24       try {
25         const coworkingSpaceData = await getCoworkingSpaceByManagerId(managerIdData);
26         if (coworkingSpaceData) {
27           setCoworkingSpace(coworkingSpaceData);
28         } else {
29           setCoworkingSpace(null);
30         }
31       } catch (error) {
32         console.error('Error fetching coworking space:', error);
33         setError('Failed to fetch coworking space');
34       } finally {
35         setLoading(false);
36       }
37     };
38
39     if (managerIdData) {
40       fetchCoworkingSpace();
41     } else {
42       setLoading(false);
43     }
44   }, [managerIdData]);
45
46   useEffect(() => {
47     const fetchRooms = async () => {
48       if (coworkingSpace) {
49         try {
50           const roomsData = await getAllRooms();
51           const filteredRooms = roomsData.filter(room => room.coworkingSpace.coworkingSpaceId == coworkingSpace[0].coworkingSpaceId);
52           const roomsWithWorkplaces = await Promise.all(
53             filteredRooms.map(async (room) => {
54               const workplacesResponse = await getAllWorkplacesByRoomId(room.roomId);
55               return {
56                 ...room,
57                 workplaces: workplacesResponse,
58               };
59             })
60           );
61
62           setRooms(roomsWithWorkplaces);
63         } catch (error) {
64           console.error('Error fetching rooms:', error);
65           setRooms([]);
66         }
67       }
68     };
69
70     fetchRooms();
71   }, [coworkingSpace]);
72
73   const handleRoomInputChange = (event) => {
74     const { name, value } = event.target;
75     setNewRoomData({
76       ...newRoomData,
77       [name]: value,
78     });
79   };
80
81   const handleWorkplaceInputChange = (event) => {
82     const { name, value } = event.target;
83     setNewWorkplaceData({
84       ...newWorkplaceData,
85       [name]: value,
86     });
87   };
88
89   const handleRoomSubmit = async (event) => {
90     event.preventDefault();
91     try {
92       const newRoom = {
93         roomName: newRoomData.roomName,
94         description: newRoomData.description,
95         coworkingSpaceId: coworkingSpace[0].coworkingSpaceId,
96       };
97       await createRoom(newRoom);
98       // Refresh the rooms data after adding a new room
99       const roomsData = await getAllRooms();
100      const filteredRooms = roomsData.filter(room => room.coworkingSpace.coworkingSpaceId == coworkingSpace[0].coworkingSpaceId);
101      const roomsWithWorkplaces = await Promise.all(
102        filteredRooms.map(async (room) => {
103          const workplacesResponse = await getAllWorkplacesByRoomId(room.roomId);
104          return {
105            ...room,
106            workplaces: workplacesResponse,
107          };
108        })
109      );
110      setRooms(roomsWithWorkplaces);
111    } catch (error) {
112      console.error('Error creating room:', error);
113      setError('Failed to create room');
114    }
115  };
116
117  const handleWorkplaceSubmit = async (event) => {
118    event.preventDefault();
119    try {
120      const newWorkplace = {
121        roomId: parseInt(newWorkplaceData.roomId, 10),
122        hourlyRate: parseFloat(newWorkplaceData.hourlyRate),
123      };
124      await createWorkplace(newWorkplace);
125      // Refresh the rooms data after adding a new workplace
126      const roomsData = await getAllRooms();
127      const filteredRooms = roomsData.filter(room => room.coworkingSpace.coworkingSpaceId == coworkingSpace[0].coworkingSpaceId);
128      const roomsWithWorkplaces = await Promise.all(
129        filteredRooms.map(async (room) => {
130          const workplacesResponse = await getAllWorkplacesByRoomId(room.roomId);
131          return {
132            ...room,
133            workplaces: workplacesResponse,
134          };
135        })
136      );
137      setRooms(roomsWithWorkplaces);
138    } catch (error) {
139      console.error('Error creating workplace:', error);
140      setError('Failed to create workplace');
141    }
142  };
143
144  if (loading) {
145    return <div>Loading...</div>;
146  }
147
148  if (error) {
149    return <div>Error: {error}</div>;
150  }
151
152  if (!coworkingSpace) {
153    return <div>You are not assigned to any coworking space.</div>;
154  }
155
156  return (
157    <main className="main py-5">
158      <div className="container">
159        <div className="rooms">
160          <h1>{coworkingSpace[0].name}</h1>
161          <form onSubmit={handleRoomSubmit}>
162            <h2><FormattedMessage id="adminRooms.addNewRoom" defaultMessage="Add New Room" /></h2>
163            <div>
164              <label>
165                <FormattedMessage id="adminRooms.roomName" defaultMessage="Room Name:" />
166                <input
167                  type="text"
168                  name="roomName"
169                  value={newRoomData.roomName}
170                  onChange={handleRoomInputChange}
171                  required
172                />
173              </label>
174            </div>
175            <div>
176              <label>
177                <FormattedMessage id="adminRooms.description" defaultMessage="Description:" />
178                <input
179                  type="text"
180                  name="description"
181                  value={newRoomData.description}
182                  onChange={handleRoomInputChange}
183                  required
184                />
185              </label>
186            </div>
187            <button type="submit"><FormattedMessage id="adminRooms.addRoom" defaultMessage="Add Room" /></button>
188          </form>
189          <form onSubmit={handleWorkplaceSubmit}>
190            <h2><FormattedMessage id="adminRooms.addNewWorkplace" defaultMessage="Add New Workplace" /></h2>
191            <div>
192              <label>
193                <FormattedMessage id="adminRooms.roomID:" defaultMessage="Room ID:" />
194                <input
195                  type="number"
196                  name="roomId"
197                  value={newWorkplaceData.roomId}
198                  onChange={handleWorkplaceInputChange}
199                  required
200                />
201              </label>
202            </div>
203            <div>
204              <label>
205              <FormattedMessage id="adminRooms.HourlyRate" defaultMessage="Hourly Rate:" />
206                <input
207                  type="number"
208                  name="hourlyRate"
209                  value={newWorkplaceData.hourlyRate}
210                  onChange={handleWorkplaceInputChange}
211                  required
212                />
213              </label>
214            </div>
215            <button type="submit"><FormattedMessage id="adminRooms.AddWorkplace" defaultMessage="Add Workplace" /></button>
216          </form>
217          <div>
218            {rooms.length > 0 ? (
219              rooms.map((room) => (
220                <div key={room.roomId} className="room">
221                  <h2><FormattedMessage id="adminRooms.Room" defaultMessage="Room" /> {room.roomId}</h2>
222                  <ul>
223                    {room.workplaces.map((workplace) => (
224                      <li key={workplace.workplaceId}><FormattedMessage id="adminRooms.Workplace" defaultMessage="Workplace" /> {workplace.workplaceId}</li>
225                    ))}
226                  </ul>
227                </div>
228              ))
229            ) : (
230              <p><FormattedMessage id="adminRooms.NoRoomsAvailable" defaultMessage="No rooms available" /></p>
231            )}
232          </div>
233        </div>
234      </div>
235    </main>
236  );
237 };
238
239 export default AdminRooms;


Г4. Код файла «BookingWindow.js»:

1  // src/BookingWindow.js
2  import React, { useEffect, useState, useContext } from 'react';
3  import { getBookingsByWorkplaceId, createBooking } from '../../services/BookingsService';
4  import { AuthContext } from '../../contexts/AuthContext';
5  import '../../styles/bookingWindow.css';
6  import { FormattedMessage } from 'react-intl';
7
8  const BookingWindow = ({ workplaceId, onClose }) => {
9    const [bookings, setBookings] = useState([]);
10   const [selectedDate, setSelectedDate] = useState(null);
11   const [selectedTime, setSelectedTime] = useState(null);
12
13   useEffect(() => {
14     const fetchBookings = async () => {
15       try {
16         const bookingsData = await getBookingsByWorkplaceId(workplaceId);
17         setBookings(bookingsData);
18       } catch (error) {
19         console.error('Error fetching bookings:', error);
20       }
21     };
22
23     fetchBookings();
24   }, [workplaceId]);
25
26   const handleBooking = async () => {
27     if (selectedDate && selectedTime) {
28       const startDateTime = new Date(`${selectedDate}T${selectedTime}:00`);
29       const endDateTime = new Date(startDateTime);
30       endDateTime.setHours(startDateTime.getHours() + 1);
31
32       const userData = localStorage.getItem('user');
33       let user = null;
34       if (userData) {
35         user = JSON.parse(userData);
36       }
37
38       const bookingData = {
39         userId: user.userId,
40         startDateTime: startDateTime.toISOString(),
41         endDateTime: endDateTime.toISOString(),
42         workplacesId: [workplaceId]
43       };
44
45       try {
46         const response = await createBooking(bookingData);
47         alert('Booking created successfully');
48         onClose();
49       } catch (error) {
50         console.error('Error creating booking:', error);
51         alert('Failed to create booking');
52       }
53     } else {
54       alert('Please select a date and time');
55     }
56   };
57
58   const isTimeBooked = (date, time) => {
59     const startDateTime = new Date(`${date}T${time}:00`);
60     return bookings.some(booking => {
61       const bookingStart = new Date(booking.startDateTime);
62       const bookingEnd = new Date(booking.endDateTime);
63       return startDateTime >= bookingStart && startDateTime < bookingEnd;
64     });
65   };
66
67   const hours = Array.from({ length: 13 }, (_, i) => i + 8);
68
69   return (
70     <div className="booking-window">
71       <h2><FormattedMessage id="userRooms.BookWorkplace" defaultMessage="Book Workplace" /></h2>
72       <button onClick={onClose}>Close</button>
73       <input
74         type="date"
75         value={selectedDate || ''}
76         onChange={(e) => setSelectedDate(e.target.value)}
77       />
78       {selectedDate && (
79         <div>
80           {hours.map((hour) => {
81             const time = hour.toString().padStart(2, '0') + ':00';
82             return (
83               <button
84                 key={hour}
85                 disabled={isTimeBooked(selectedDate, time)}
86                 className={`booking-time-button ${selectedTime === time ? 'selected' : ''}`}
87                 onClick={() => setSelectedTime(time)}
88               >
89                 {time}
90               </button>
91             );
92           })}
93         </div>
94       )}
95       <button onClick={handleBooking}><FormattedMessage id="userRooms.Book" defaultMessage="Book" /></button>
96     </div>
97   );
98 };
99
100 export default BookingWindow;


Г5. Код файла «UserRoomsPage.js»:

1  // src/Rooms.js
2  import React, { useEffect, useState } from 'react';
3  import Room from './Room';
4  import BookingWindow from './BookingWindow';
5  import { getAllRooms } from '../../services/RoomsService';
6  import { getAllWorkplacesByRoomId } from '../../services/WorkplacesService';
7  import { getAllCoworkingSpaces } from '../../services/CoworkingSpacesService';
8  import { FormattedMessage } from 'react-intl';
9
10 const Rooms = () => {
11   const [coworkingSpaces, setCoworkingSpaces] = useState([]);
12   const [selectedCoworkingSpace, setSelectedCoworkingSpace] = useState(null);
13   const [rooms, setRooms] = useState([]);
14   const [selectedWorkplace, setSelectedWorkplace] = useState(null);
15
16   useEffect(() => {
17     const fetchCoworkingSpaces = async () => {
18       try {
19         const coworkingSpacesData = await getAllCoworkingSpaces();
20         setCoworkingSpaces(coworkingSpacesData);
21         console.log('Coworking spaces:', coworkingSpacesData);
22       } catch (error) {
23         console.error('Error fetching coworking spaces:', error);
24       }
25     };
26
27     fetchCoworkingSpaces();
28   }, []);
29
30   useEffect(() => {
31     const fetchRooms = async () => {
32       if (selectedCoworkingSpace) {
33         try {
34           const roomsData = await getAllRooms();
35           console.log('All rooms:', roomsData);
36
37           const filteredRooms = roomsData.filter(room => {
38             const match = room.coworkingSpace && room.coworkingSpace.coworkingSpaceId === selectedCoworkingSpace;
39             console.log(`Room ID ${room.roomId} match:`, match);
40             return match;
41           });
42           console.log('Filtered rooms:', filteredRooms);
43
44           const roomsWithWorkplaces = await Promise.all(
45             filteredRooms.map(async (room) => {
46               const workplacesResponse = await getAllWorkplacesByRoomId(room.roomId);
47               return {
48                 ...room,
49                 workplaces: workplacesResponse,
50               };
51             })
52           );
53
54           console.log('Rooms with workplaces:', roomsWithWorkplaces);
55           setRooms(roomsWithWorkplaces);
56         } catch (error) {
57           console.error('Error fetching rooms:', error);
58           setRooms([]);
59         }
60       }
61     };
62
63     fetchRooms();
64   }, [selectedCoworkingSpace]);
65
66   return (
67     <main className="main py-5">
68       <div className="container">
69         <div className="rooms">
70           <h1><FormattedMessage id="userRooms.Coworkings" defaultMessage="Coworkings" /></h1>
71           <select
72             value={selectedCoworkingSpace || ''}
73             onChange={(e) => setSelectedCoworkingSpace(parseInt(e.target.value))}
74           >
75             <option value="" disabled><FormattedMessage id="userRooms.Selectacoworkingspace" defaultMessage="Select a coworking space" /></option>
76             {coworkingSpaces.map((space) => (
77               <option key={space.coworkingSpaceId} value={space.coworkingSpaceId}>
78                 {space.name}, {space.address}, {space.city}
79               </option>
80             ))}
81           </select>
82           <div>
83           {rooms.length > 0 ? (
84             rooms.map((room) => (
85               <Room
86                 key={room.roomId}
87                 roomNumber={room.roomId}
88                 workplaces={room.workplaces}
89                 setSelectedWorkplace={setSelectedWorkplace}
90                 selectedWorkplace={selectedWorkplace}
91               />
92             ))
93           ) : (
94             <p><FormattedMessage id="userRooms.Noroomsavailable" defaultMessage="No rooms available" /></p>
95           )}
96         </div>
97           {selectedWorkplace && (
98             <BookingWindow workplaceId={selectedWorkplace} onClose={() => setSelectedWorkplace(null)} />
99           )}
100        </div>
101      </div>
102    </main>
103  );
104 };
105
106 export default Rooms;


Г6. Код файла «RoomsService.js»:

1  import apiInstance from './ApiService';
2
3  export const getAllRooms = async () => {
4      try {
5          const response = await apiInstance.get('/api/rooms');
6          return response.data;
7      } catch (error) {
8          console.error('Error fetching rooms:', error);
9          throw error;
10     }
11 };
12
13 export const createRoom = async (roomData) => {
14     try {
15       const response = await apiInstance.post('/api/rooms', roomData);
16       return response.data;
17     } catch (error) {
18       console.error('Error creating room:', error);
19       throw error;
20     }
21 };


Г7. Код файла «CoworkingSpacesService.js»:

1  import apiInstance from './ApiService';
2  
3  export const getAllCoworkingSpaces = async () => {
4    try {
5      const response = await apiInstance.get('/api/coworkingSpaces');
6      return response.data;
7    } catch (error) {
8      console.error('Error fetching coworking spaces:', error);
9      throw error;
10   }
11 };
12 
13 export const getCoworkingSpaceByManagerId = async (managerId) => {
14   try {
15     const response = await apiInstance.get(`/api/coworkingSpaces/byManager/${managerId}`);
16     return response.data;
17   } catch (error) {
18     console.error('Error fetching coworking space by manager ID:', error);
19     throw error;
20   }
21 };


ДОДАТОК Д
Код мобільного застосунка
Д1. Код файла «BookingsPage.xaml»:

1 <?xml version="1.0" encoding="utf-8" ?>
2 <ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
3              xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
4              xmlns:viewModels="clr-namespace:coworkings_mobile.ViewModels"
5              xmlns:resources="clr-namespace:coworkings_mobile.Resources.Languages"
6              x:Class="coworkings_mobile.Views.BookingsPage"
7              Title="{x:Static resources:AppResources.BookingTitle}">
8     <Shell.TitleView>
9         <Grid>
10            <Grid.ColumnDefinitions>
11                <ColumnDefinition Width="*" />
12                <ColumnDefinition Width="Auto" />
13            </Grid.ColumnDefinitions>
14            <Label x:Name="PageTitleLabel" FontSize="20" FontAttributes="Bold" TextColor="White" VerticalOptions="Center" Grid.Column="0" />
15            <ImageButton Source="language_icon.png" Clicked="NavigateToLanguageSelection" HorizontalOptions="End" Grid.Column="1" />
16        </Grid>
17    </Shell.TitleView>
18    <ScrollView>
19        <Grid Margin="20">
20            <Grid.RowDefinitions>
21                <RowDefinition Height="Auto" />
22                <RowDefinition Height="*" />
23            </Grid.RowDefinitions>
24            <Label x:Name="PageTitleTextLabel" FontSize="24" HorizontalOptions="Center" Margin="0,0,0,20" />
25            <ScrollView Orientation="Horizontal" Grid.Row="1">
26                <Grid>
27                    <Grid.RowDefinitions>
28                        <RowDefinition Height="Auto" />
29                        <RowDefinition Height="*" />
30                    </Grid.RowDefinitions>
31                    <Grid.ColumnDefinitions>
32                        <ColumnDefinition Width="120" />
33                        <ColumnDefinition Width="120" />
34                        <ColumnDefinition Width="120" />
35                        <ColumnDefinition Width="120" />
36                        <ColumnDefinition Width="120" />
37                        <ColumnDefinition Width="120" />
38                    </Grid.ColumnDefinitions>
39                    <Border Background="LightGray" Grid.Row="0" Grid.Column="0" Padding="5">
40                        <Label x:Name="StartDateLabelTitle" FontAttributes="Bold" />
41                    </Border>
42                    <Border Background="LightGray" Grid.Row="0" Grid.Column="1" Padding="5">
43                        <Label x:Name="StartTimeLabelTitle" FontAttributes="Bold" />
44                    </Border>
45                    <Border Background="LightGray" Grid.Row="0" Grid.Column="2" Padding="5">
46                        <Label x:Name="EndDateLabelTitle" FontAttributes="Bold" />
47                    </Border>
48                    <Border Background="LightGray" Grid.Row="0" Grid.Column="3" Padding="5">
49                        <Label x:Name="EndTimeLabelTitle" FontAttributes="Bold" />
50                    </Border>
51                    <Border Background="LightGray" Grid.Row="0" Grid.Column="4" Padding="5">
52                        <Label x:Name="BookingCodeLabelTitle" FontAttributes="Bold" />
53                    </Border>
54                    <CollectionView Grid.Row="1" Grid.Column="0" Grid.ColumnSpan="6" ItemsSource="{Binding Bookings}">
55                        <CollectionView.ItemsLayout>
56                            <GridItemsLayout Orientation="Vertical" Span="1" />
57                        </CollectionView.ItemsLayout>
58                        <CollectionView.ItemTemplate>
59                            <DataTemplate>
60                                <Grid Margin="0,0,0,10">
61                                    <Grid.ColumnDefinitions>
62                                        <ColumnDefinition Width="120" />
63                                        <ColumnDefinition Width="120" />
64                                        <ColumnDefinition Width="120" />
65                                        <ColumnDefinition Width="120" />
66                                        <ColumnDefinition Width="120" />
67                                        <ColumnDefinition Width="120" />
68                                    </Grid.ColumnDefinitions>
69                                    <Border Stroke="LightGray" StrokeThickness="0.5" Grid.Column="0" Padding="5">
70                                        <Label Text="{Binding FormattedStartDate}" LineBreakMode="WordWrap" />
71                                    </Border>
72                                    <Border Stroke="LightGray" StrokeThickness="0.5" Grid.Column="1" Padding="5">
73                                        <Label Text="{Binding FormattedStartTime}" LineBreakMode="WordWrap" />
74                                    </Border>
75                                    <Border Stroke="LightGray" StrokeThickness="0.5" Grid.Column="2" Padding="5">
76                                        <Label Text="{Binding FormattedEndDate}" LineBreakMode="WordWrap" />
77                                    </Border>
78                                    <Border Stroke="LightGray" StrokeThickness="0.5" Grid.Column="3" Padding="5">
79                                        <Label Text="{Binding FormattedEndTime}" LineBreakMode="WordWrap" />
80                                    </Border>
81                                    <Border Stroke="LightGray" StrokeThickness="0.5" Grid.Column="4" Padding="5">
82                                        <Label Text="{Binding BookingCode}" LineBreakMode="WordWrap" />
83                                    </Border>
84                                </Grid>
85                            </DataTemplate>
86                        </CollectionView.ItemTemplate>
87                    </CollectionView>
88                </Grid>
89            </ScrollView>
90        </Grid>
91    </ScrollView>
92 </ContentPage>


Д2. Код файла «BookingsPage.xaml.cs»:

1  using coworkings_mobile.Resources.Languages;
2  using coworkings_mobile.ViewModels;
3  
4  namespace coworkings_mobile.Views;
5  
6  public partial class BookingsPage : ContentPage
7  {
8      private readonly BookingsViewModel _viewModel;
9  
10     public BookingsPage()
11     {
12         InitializeComponent();
13         _viewModel = new BookingsViewModel();
14         BindingContext = _viewModel;
15     }
16 
17     protected override void OnAppearing()
18     {
19         base.OnAppearing();
20         _viewModel.LoadBookingsCommand.Execute(null);
21         UpdateLocalization();
22     }
23 
24     private void UpdateLocalization()
25     {
26         PageTitleLabel.Text = AppResources.BookingTitle;
27         PageTitleTextLabel.Text = AppResources.BookingTitle;
28         StartDateLabelTitle.Text = AppResources.StartDateLabel;
29         StartTimeLabelTitle.Text = AppResources.StartTimeLabel;
30         EndDateLabelTitle.Text = AppResources.EndDateLabel;
31         EndTimeLabelTitle.Text = AppResources.EndTimeLabel;
32         BookingCodeLabelTitle.Text = AppResources.BookingCodeLabel;
33     }
34 
35     private async void NavigateToLanguageSelection(object sender, EventArgs e)
36     {
37         await Navigation.PushAsync(new LanguageSelectionPage());
38     }
39 }


Д3. Код файла «CurrentBookingPage.xaml»:

1  <?xml version="1.0" encoding="utf-8" ?>
2  <ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
3               xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
4               xmlns:viewModels="clr-namespace:coworkings_mobile.ViewModels"
5               xmlns:resources="clr-namespace:coworkings_mobile.Resources.Languages"
6               x:Class="coworkings_mobile.Views.CurrentBookingPage"
7               Title="{x:Static resources:AppResources.CurrentBookingTitle}">
8      <Shell.TitleView>
9          <Grid>
10             <Grid.ColumnDefinitions>
11                 <ColumnDefinition Width="*" />
12                 <ColumnDefinition Width="Auto" />
13             </Grid.ColumnDefinitions>
14             <Label x:Name="PageTitleLabel" FontSize="20" FontAttributes="Bold" TextColor="White" VerticalOptions="Center" Grid.Column="0" />
15             <ImageButton Source="language_icon.png" Clicked="NavigateToLanguageSelection" HorizontalOptions="End" Grid.Column="1" />
16         </Grid>
17     </Shell.TitleView>
18     <ContentPage.BindingContext>
19         <viewModels:CurrentBookingViewModel />
20     </ContentPage.BindingContext>
21     <StackLayout Padding="20" Spacing="20">
22         <Label x:Name="CurrentBookingTitle" Text="{x:Static resources:AppResources.CurrentBookingTitle}" 
23                FontSize="28" 
24                FontAttributes="Bold" 
25                HorizontalOptions="Center" />
26         <StackLayout x:Name="BookingDetails" IsVisible="{Binding HasCurrentBooking}">
27             <Label x:Name="StartDateLabel" Text="{x:Static resources:AppResources.StartDateLabel}" 
28                    FontSize="20" 
29                    FontAttributes="Bold" />
30             <Label Text="{Binding Booking.FormattedStartDate}" 
31                    FontSize="18" 
32                    Margin="0,0,0,10" />
33             <Label x:Name="StartTimeLabel" Text="{x:Static resources:AppResources.StartTimeLabel}" 
34                    FontSize="20" 
35                    FontAttributes="Bold" />
36             <Label Text="{Binding Booking.FormattedStartTime}" 
37                    FontSize="18" 
38                    Margin="0,0,0,10" />
39             <Label x:Name="EndDateLabel" Text="{x:Static resources:AppResources.EndDateLabel}" 
40                    FontSize="20" 
41                    FontAttributes="Bold" />
42             <Label Text="{Binding Booking.FormattedEndDate}" 
43                    FontSize="18" 
44                    Margin="0,0,0,10" />
45             <Label x:Name="EndTimeLabel" Text="{x:Static resources:AppResources.EndTimeLabel}" 
46                    FontSize="20" 
47                    FontAttributes="Bold" />
48             <Label Text="{Binding Booking.FormattedEndTime}" 
49                    FontSize="18" 
50                    Margin="0,0,0,10" />
51             <Label x:Name="BookingCodeLabel" Text="{x:Static resources:AppResources.BookingCodeLabel}" 
52                    FontSize="20" 
53                    FontAttributes="Bold" />
54             <Label Text="{Binding Booking.BookingCode}" 
55                    FontSize="24" 
56                    FontAttributes="Bold" 
57                    TextColor="Blue" 
58                    HorizontalOptions="Center" 
59                    Margin="0,10,0,10" />
60             <Label Text="{Binding CountdownText}" 
61                    FontAttributes="Bold" 
62                    FontSize="22" 
63                    TextColor="Red" 
64                    HorizontalOptions="Center" />
65         </StackLayout>
66         <Label x:Name="NoCurrentBookingMessage" 
67                Text="{x:Static resources:AppResources.NoCurrentBookingMessage}" 
68                IsVisible="{Binding NoCurrentBooking}" 
69                FontSize="18" 
70                HorizontalOptions="Center" 
71                VerticalOptions="CenterAndExpand" />
72     </StackLayout>
73 </ContentPage>


Д4. Код файла «CurrentBookingPage.xaml.cs»:

1  using coworkings_mobile.Resources.Languages;
2  using coworkings_mobile.ViewModels;
3  using Microsoft.Maui.Controls;
4  
5  namespace coworkings_mobile.Views
6  {
7      public partial class CurrentBookingPage : ContentPage
8      {
9          private readonly CurrentBookingViewModel _viewModel;
10 
11         public CurrentBookingPage()
12         {
13             InitializeComponent();
14             _viewModel = (CurrentBookingViewModel)BindingContext;
15             UpdateLocalization();
16         }
17 
18         protected override void OnAppearing()
19         {
20             base.OnAppearing();
21             _viewModel.LoadCurrentBookingCommand.Execute(null);
22             UpdateLocalization();
23         }
24 
25         private async void NavigateToLanguageSelection(object sender, EventArgs e)
26         {
27             await Navigation.PushAsync(new LanguageSelectionPage());
28         }
29 
30         private void UpdateLocalization()
31         {
32             CurrentBookingTitle.Text = AppResources.CurrentBookingTitle;
33             StartDateLabel.Text = AppResources.StartDateLabel;
34             StartTimeLabel.Text = AppResources.StartTimeLabel;
35             EndDateLabel.Text = AppResources.EndDateLabel;
36             EndTimeLabel.Text = AppResources.EndTimeLabel;
37             BookingCodeLabel.Text = AppResources.BookingCodeLabel;
38             NoCurrentBookingMessage.Text = AppResources.NoCurrentBookingMessage;
39         }
40     }
41 }


Д5. Код файла «BookingsViewModel.cs»:

1  using coworkings_mobile.Models;
2  using coworkings_mobile.Resources.Languages;
3  using coworkings_mobile.Services;
4  using Newtonsoft.Json;
5  using System;
6  using System.Collections.Generic;
7  using System.Collections.ObjectModel;
8  using System.ComponentModel;
9  using System.Globalization;
10 using System.Windows.Input;
11 
12 namespace coworkings_mobile.ViewModels
13 {
14     public class BookingsViewModel
15     {
16         private readonly BookingService _bookingService;
17         private readonly AuthService _authService;
18 
19         public ObservableCollection<Booking> Bookings { get; }
20         public ICommand LoadBookingsCommand { get; }
21 
22         public BookingsViewModel()
23         {
24             _bookingService = new BookingService();
25             _authService = new AuthService();
26             Bookings = new ObservableCollection<Booking>();
27             LoadBookingsCommand = new Command(async () => await LoadBookings());
28         }
29 
30         private async Task LoadBookings()
31         {
32             var user = _authService.GetUser();
33             if (user != null)
34             {
35                 var history = await _bookingService.GetUserBookings(user.UserId);
36                 Bookings.Clear();
37 
38                 foreach (var item in history)
39                 {
40                     Bookings.Add(item);
41                 }
42             }
43         }
44     }
45 }


Д6. Код файла «CurrentBookingViewModel.cs»:

1  using coworkings_mobile.Models;
2  using coworkings_mobile.Services;
3  using System;
4  using System.ComponentModel;
5  using System.Threading.Tasks;
6  using System.Windows.Input;
7  
8  namespace coworkings_mobile.ViewModels
9  {
10     public class CurrentBookingViewModel : INotifyPropertyChanged
11     {
12         private readonly BookingService _bookingService;
13         private readonly AuthService _authService;
14         private Booking _booking;
15         private string _countdownText;
16         private bool _hasCurrentBooking;
17         private bool _noCurrentBooking;
18 
19         public Booking Booking
20         {
21             get => _booking;
22             set
23             {
24                 _booking = value;
25                 OnPropertyChanged(nameof(Booking));
26             }
27         }
28 
29         public string CountdownText
30         {
31             get => _countdownText;
32             set
33             {
34                 _countdownText = value;
35                 OnPropertyChanged(nameof(CountdownText));
36             }
37         }
38 
39         public bool HasCurrentBooking
40         {
41             get => _hasCurrentBooking;
42             set
43             {
44                 _hasCurrentBooking = value;
45                 OnPropertyChanged(nameof(HasCurrentBooking));
46             }
47         }
48 
49         public bool NoCurrentBooking
50         {
51             get => _noCurrentBooking;
52             set
53             {
54                 _noCurrentBooking = value;
55                 OnPropertyChanged(nameof(NoCurrentBooking));
56             }
57         }
58 
59         public ICommand LoadCurrentBookingCommand { get; }
60 
61         public event PropertyChangedEventHandler PropertyChanged;
62 
63         public CurrentBookingViewModel()
64         {
65             _bookingService = new BookingService();
66             _authService = new AuthService();
67             LoadCurrentBookingCommand = new Command(async () => await LoadCurrentBooking());
68         }
69 
70         private async Task LoadCurrentBooking()
71         {
72             var user = _authService.GetUser();
73             if (user != null)
74             {
75                 Booking = await _bookingService.GetCurrentBooking(user.UserId);
76                 if (Booking != null)
77                 {
78                     HasCurrentBooking = true;
79                     NoCurrentBooking = false;
80                     StartCountdown();
81                 }
82                 else
83                 {
84                     HasCurrentBooking = false;
85                     NoCurrentBooking = true;
86                 }
87             }
88         }
89 
90         private void StartCountdown()
91         {
92             Device.StartTimer(TimeSpan.FromSeconds(1), () =>
93             {
94                 if(Booking == null)
95                 {
96                     return false;
97                 }
98                 var timeRemaining = Booking.EndDateTime - DateTime.Now;
99                 if (timeRemaining > TimeSpan.Zero)
100                {
101                    CountdownText = $"Time left: {timeRemaining:hh\\:mm\\:ss}";
102                    return true;
103                }
104                else
105                {
106                    CountdownText = "Expired";
107                    HasCurrentBooking = false;
108                    NoCurrentBooking = true;
109                    return false;
110                }
111            });
112        }
113 
114        protected virtual void OnPropertyChanged(string propertyName)
115        {
116            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
117        }
118    }
119 }
